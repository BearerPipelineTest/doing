#!/usr/bin/env ruby
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'doing'
require 'tempfile'
require 'pp'

def class_exists?(class_name)
  klass = Module.const_get(class_name)
  klass.is_a?(Class)
rescue NameError
  false
end

if class_exists? 'Encoding'
  Encoding.default_external = Encoding::UTF_8 if Encoding.respond_to?('default_external')
  Encoding.default_internal = Encoding::UTF_8 if Encoding.respond_to?('default_internal')
end

include GLI::App
version Doing::VERSION

wwid = WWID.new
wwid.user_home = if Dir.respond_to?('home')
                   Dir.home
                 else
                   File.expand_path('~')
                 end
wwid.configure

program_desc 'A CLI for a What Was I Doing system'

default_command :recent
# sort_help :manually

desc 'Output notes if included in the template'
switch [:notes], default_value: true, negatable: true

desc 'Send results report to STDOUT instead of STDERR'
switch [:stdout], default_value: false, negatable: false

desc 'Exclude auto tags and default tags'
switch %i[x noauto], default_value: false

desc 'Use a specific configuration file'
flag [:config_file], default_value: wwid.config_file

desc 'Specify a different doing_file'
flag %i[f doing_file]

desc 'Add an entry'
arg_name 'ENTRY'
command [:now, :next] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Backdate start time [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Timed entry, marks last entry in section as @done'
  c.switch %i[f finish_last], negatable: false, default_value: false

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  # c.desc "Edit entry with specified app"
  # c.arg_name 'editor_app'
  # # c.flag [:a, :app]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back])

      raise 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    if options[:e] || (args.empty? && $stdin.stat.size.zero?)
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = ''
      input += args.join(' ') unless args.empty?
      input = wwid.fork_editor(input).strip

      raise 'No content' if input.empty?

      title, note = wwid.format_input(input)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    elsif args.length.positive?
      title, note = wwid.format_input(args.join(' '))
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    else
      raise 'You must provide content when creating a new entry'
    end
  end
end

desc 'Add a note to the last entry'
long_desc %(
  If -r is provided with no other arguments, the last note is removed. If new content is specified through arguments or STDIN, any previous note will be replaced with the new one.

  Use -e to load the last entry in a text editor where you can append a note.
)
arg_name 'NOTE_TEXT'
command :note do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc "Replace/Remove last entry's note (default append)"
  c.switch %i[r remove], negatable: false, default_value: false

  c.action do |_global_options, options, args|
    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    if options[:e] || (args.empty? && $stdin.stat.size.zero? && !options[:r])
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = !args.empty? ? args.join(' ') : ''

      prev_input = wwid.last_note(section) || ''
      prev_input = prev_input.join("\n") if prev_input.instance_of?(Array)
      input = prev_input + input

      input = wwid.fork_editor(input).strip
      raise 'No content, cancelled' unless input

      _title, note = wwid.format_input(input)

      raise 'No note content' unless note

      wwid.note_last(section, note, replace: true)
    elsif !args.empty?
      title, note = wwid.format_input(args.join(' '))
      note.insert(0, title)
      wwid.note_last(section, note, replace: options[:r])
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      note.insert(0, title)
      wwid.note_last(section, note, replace: options[:r])
    elsif options[:r]
      wwid.note_last(section, [], replace: true)
    else
      raise 'You must provide content when adding a note'
    end
    wwid.write(wwid.doing_file)
  end
end

desc 'Finish any running @meanwhile tasks and optionally create a new one'
arg_name 'ENTRY'
command :meanwhile do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Archive previous @meanwhile entry'
  c.switch %i[a archive], default_value: false

  c.desc 'Backdate start date for new entry to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back])

      raise 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    section = wwid.guess_section(options[:s]) || options[:s].cap_first
    input = ''

    if options[:e]
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input += args.join(' ') unless args.empty?
      input = wwid.fork_editor(input).strip
    elsif !args.empty?
      input = args.join(' ')
    elsif $stdin.stat.size.positive?
      input = $stdin.read
    end

    if input && !input.empty?
      input, note = wwid.format_input(input)
    else
      input = nil
      note = []
    end

    if options[:n]
      note.push(options[:n])
    elsif note.empty?
      note = nil
    end

    wwid.stop_start('meanwhile', { new_item: input, back: date, section: section, archive: options[:a], note: note })
    wwid.write(wwid.doing_file)
  end
end

desc 'Output HTML and CSS templates for customization'
long_desc %(
  Templates are printed to STDOUT for piping to a file.
  Save them and use them in the configuration file under html_template.

  Example `doing template HAML > ~/styles/my_doing.haml`
)
arg_name 'TYPE', must_match: /^(html|haml|css)/i
command :template do |c|
  c.action do |_global_options, options, args|
    raise 'No type specified, use `doing template [HAML|CSS]`' if args.empty?

    case options[:t]
    when /html|haml/i
      $stdout.puts wwid.haml_template
    when /css/i
      $stdout.puts wwid.css_template
    else
      raise 'Invalid type specified, must be HAML or CSS'
    end
  end
end

desc 'Add an item to the Later section'
arg_name 'ENTRY'
command :later do |c|
  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Edit entry with specified app'
  c.arg_name 'APP'
  c.flag %i[a app]

  c.desc 'Backdate start time to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back])
      raise 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    if options[:e] || (args.empty? && $stdin.stat.size.zero?)
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = args.empty? ? '' : args.join(' ')
      input = wwid.fork_editor(input).strip
      raise 'No content' unless input && !input.empty?

      title, note = wwid.format_input(input)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif !args.empty?
      title, note = wwid.format_input(args.join(' '))
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    else
      raise 'You must provide content when creating a new entry'
    end
  end
end

desc 'Add a completed item with @done(date). No argument finishes last entry.'
arg_name 'ENTRY'
command [:done, :did] do |c|
  c.desc 'Remove @done tag'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Include date'
  c.switch [:date], negatable: true, default_value: true

  c.desc 'Immediately archive the entry'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc %(Set finish date to specific date/time (natural langauge parsed, e.g. --at=1:30pm).
  If used, ignores --back. Used with --took, backdates start date)
  c.arg_name 'DATE_STRING'
  c.flag [:at]

  c.desc 'Backdate start date by interval [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc %(Set completion date to start date plus interval (XX[mhd] or HH:MM).
  If used without the --back option, the start date will be moved back to allow
  the completion date to be the current time.)
  c.arg_name 'INTERVAL'
  c.flag %i[t took]

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  # c.desc "Edit entry with specified app"
  # c.arg_name 'editor_app'
  # # c.flag [:a, :app]

  c.action do |_global_options, options, args|
    took = 0

    if options[:took]
      took = wwid.chronify_qty(options[:took])
      raise 'Unable to parse date string for --took' if took.nil?
    end

    if options[:back]
      date = wwid.chronify(options[:back])
      raise 'Unable to parse date string for --back' if date.nil?
    else
      date = options[:took] ? Time.now - took : Time.now
    end

    if options[:at]
      finish_date = wwid.chronify(options[:at])
      raise 'Unable to parse date string for --at' if finish_date.nil?

      date = options[:took] ? finish_date - took : finish_date
    elsif options[:took]
      finish_date = date + took
    elsif options[:back]
      finish_date = date
    else
      finish_date = Time.now
    end

    section = wwid.guess_section(options[:s]) || options[:s].cap_first
    donedate = options[:date] ? "(#{finish_date.strftime('%F %R')})" : ''

    if options[:e]
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = ''
      input += args.join(' ') unless args.empty?
      input = wwid.fork_editor(input).strip
      raise 'No content' unless input && !input.empty?

      title, note = wwid.format_input(input)
      title += " @done#{donedate}"
      section = 'Archive' if options[:a]
      wwid.add_item(title.cap_first, section.cap_first, { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif args.empty? && $stdin.stat.size.zero?
      if options[:r]
        wwid.tag_last({ tags: ['done'], count: 1, section: section, remove: true })
      else
        wwid.tag_last({ tags: ['done'], count: 1, section: section, archive: options[:a], back: finish_date,
                        date: options[:date] })
      end
    elsif !args.empty?
      title, note = wwid.format_input(args.join(' '))
      title.chomp!
      title += " @done#{donedate}"
      section = 'Archive' if options[:a]
      wwid.add_item(title.cap_first, section.cap_first, { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      title += " @done#{donedate}"
      section = options[:a] ? 'Archive' : section
      wwid.add_item(title.cap_first, section.cap_first, { note: note, back: date })
      wwid.write(wwid.doing_file)
    else
      raise 'You must provide content when creating a new entry'
    end
  end
end

desc 'End last X entries with no time tracked'
long_desc 'Adds @done tag without datestamp so no elapsed time is recorded. Alias for `doing finish --no-date`.'
arg_name 'COUNT'
command :cancel do |c|
  c.desc 'Archive entries'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.desc 'Cancel the last X entries containing TAG. Separate multiple tags with comma (--tag=tag1,tag2)'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: /^(and|or|not)$/i, default_value: 'AND'

  c.action do |_global_options, options, args|
    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].split(/ *, */).map { |t| t.strip.sub(/^@/, '') }
      options[:bool] = options[:bool] =~ /^(and|or|not)$/i ? options[:bool].upcase : 'AND'
    end

    raise 'Only one argument allowed' if args.length > 1

    raise 'Invalid argument (specify number of recent items to mark @done)' unless args.empty? || args[0] =~ /\d+/

    count = args[0] ? args[0].to_i : 1
    opts = {
      archive: options[:a],
      count: count,
      date: false,
      section: section,
      sequential: false,
      tag: tags,
      tag_bool: options[:bool],
      tags: ['done']
    }
    wwid.tag_last(opts)
  end
end

desc 'Mark last X entries as @done'
long_desc 'Marks the last X entries with a @done tag and current date. Does not alter already completed entries.'
arg_name 'COUNT'
command :finish do |c|
  c.desc 'Include date'
  c.switch [:date], negatable: true, default_value: true

  c.desc 'Backdate completed date to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Set the completed date to the start date plus XX[hmd]'
  c.arg_name 'INTERVAL'
  c.flag %i[t took]

  c.desc 'Finish the last X entries containing TAG.
  Separate multiple tags with comma (--tag=tag1,tag2), combine with --bool'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Finish the last X entries matching search filter, surround with slashes for regex (e.g. "/query.*/")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: /^(and|or|not)$/i, default_value: 'AND'

  c.desc %(Auto-generate finish dates from next entry's start time.
  Automatically generate completion dates 1 minute before next start date.
  --auto overrides the --date and --back parameters.)
  c.switch [:auto], negatable: false, default_value: false

  c.desc 'Archive entries'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.action do |_global_options, options, args|
    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    unless options[:auto]
      raise '--back and --took cannot be used together' if options[:back] && options[:took]

      raise '--search and --tag cannot be used together' if options[:search] && options[:tag]

      if options[:back]
        date = wwid.chronify(options[:back])

        raise 'Unable to parse date string' if date.nil?
      elsif options[:took]
        date = wwid.chronify_qty(options[:took])
      else
        date = Time.now
      end
    end

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].split(/ *, */).map { |t| t.strip.sub(/^@/, '') }
      options[:bool] = options[:bool] =~ /^(and|or|not)$/i ? options[:bool].upcase : 'AND'
    end

    raise 'Only one argument allowed' if args.length > 1

    raise 'Invalid argument (specify number of recent items to mark @done)' unless args.length == 0 || args[0] =~ /\d+/

    count = args[0] ? args[0].to_i : 1
    opts = {
      archive: options[:a],
      back: date,
      count: count,
      date: options[:date],
      search: options[:search],
      section: section,
      sequential: options[:auto],
      tag: tags,
      tag_bool: options[:bool],
      tags: ['done']
    }
    wwid.tag_last(opts)
  end
end

desc 'Repeat last entry as new entry'
command [:again, :resume] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Add new entry to section (default: same section as repeated entry)'
  c.arg_name 'SECTION_NAME'
  c.flag [:in]

  c.desc 'Repeat last entry matching tags. Combine multiple tags with a comma.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Repeat last entry matching search. Surround with
  slashes for regex (e.g. "/query/").'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean used to combine multiple tags'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: /^(and|or|not)$/i, default_value: 'ALL'

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, _args|
    tags = options[:tag].nil? ? [] : options[:tag].split(/ *, */).map { |t| t.sub(/^@/, '').strip }
    opts = {
      in: options[:in],
      note: options[:n],
      search: options[:search],
      section: options[:s],
      tag: tags,
      tag_bool: options[:bool]
    }
    wwid.restart_last(opts)
  end
end

desc 'Add tag(s) to last entry'
arg_name 'TAG', :multiple
command :tag do |c|
  c.desc 'Section'
  c.arg_name 'SECTION_NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'How many recent entries to tag (0 for all)'
  c.arg_name 'COUNT'
  c.flag %i[c count], default_value: 1

  c.desc 'Include current date/time with tag'
  c.switch %i[d date], negatable: false, default_value: false

  c.desc 'Remove given tag(s)'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Autotag entries based on autotag configuration in ~/.doingrc'
  c.switch %i[a autotag], negatable: false, default_value: false

  c.action do |_global_options, options, args|
    raise 'You must specify at least one tag' if args.empty? && !options[:a]

    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    if options[:a]
      tags = []
    else
      tags = if args.join('') =~ /,/
               args.join('').split(/,/)
             else
               args.join(' ').split(' ') # in case tags are quoted as one arg
             end

      tags.map! { |tag| tag.sub(/^@/, '').strip }
    end

    count = options[:c].to_i

    if count.zero?
      section_q = section == 'All' ? '' : " in section #{section}"

      question = if options[:a]
                   "Are you sure you want to autotag all records#{section_q}"
                 elsif options[:r]
                   "Are you sure you want to remove #{tags.join(' and ')} from all records#{section_q}"
                 else
                   "Are you sure you want to add #{tags.join(' and ')} to all records#{section_q}"
                 end

      res = wwid.yn(question, default_response: false)

      raise 'Cancelled' unless res
    end
    opts = {
      autotag: options[:a],
      count: count,
      date: options[:date],
      remove: options[:r],
      section: section,
      tags: tags
    }
    wwid.tag_last(opts)
  end
end

desc 'Mark last entry as highlighted'
command [:mark, :flag] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: wwid.current_section

  c.desc 'Remove mark'
  c.switch %i[r remove], negatable: false, default_value: false

  c.action do |_global_options, options, _args|
    mark = wwid.config['marker_tag'] || 'flagged'
    wwid.tag_last({ tags: [mark], section: options[:s], remove: options[:r] })
  end
end

desc 'List all entries'
long_desc %(
  The argument can be a section name, @tag(s) or both.
  "pick" or "choose" as an argument will offer a section menu.
)
arg_name '[SECTION|@TAGS]'
command :show do |c|
  c.desc 'Tag filter, combine multiple tags with a comma. Added for compatibility with other commands.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND,OR,NONE)'
  c.arg_name 'BOOLEAN'
  c.flag %i[b bool], must_match: /^(and|or|not)$/i, default_value: 'OR'

  c.desc 'Max count to show'
  c.arg_name 'MAX'
  c.flag %i[c count], default_value: 0

  c.desc 'Age (oldest/newest)'
  c.arg_name 'AGE'
  c.flag %i[a age], default_value: 'newest'

  c.desc 'Sort order (asc/desc)'
  c.arg_name 'ORDER'
  c.flag %i[s sort], must_match: /^(a|d)/i, default_value: 'ASC'

  c.desc %(
    Date range to show, or a single day to filter date on.
    Date range argument should be quoted. Date specifications can be natural language.
    To specify a range, use "to" or "through": `doing show --from "monday to friday"`
  )
  c.arg_name 'DATE_OR_RANGE'
  c.flag %i[f from]

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)/i, default_value: default

  c.desc 'Only show items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: false

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i
  c.action do |_global_options, options, args|
    tag_filter = false
    tags = []
    if args.length.positive?
      case args[0]
      when /^all$/i
        section = 'All'
        args.shift
      when /^(choose|pick)$/i
        section = wwid.choose_section
        args.shift
      when /^@/
        section = 'All'
      else
        section = wwid.guess_section(args[0])
        raise "No such section: #{args[0]}" unless section

        args.shift
      end
      if args.length.positive?
        args.each do |arg|
          if arg =~ /,/
            arg.split(/,/).each do |tag|
              tags.push(tag.strip.sub(/^@/, ''))
            end
          else
            tags.push(arg.strip.sub(/^@/, ''))
          end
        end
      end
    else
      section = wwid.current_section
    end

    tags.concat(options[:tag].split(/ *, */).map { |t| t.sub(/^@/, '').strip }) if options[:tag]

    unless tags.empty?
      tag_filter = {
        'tags' => tags,
        'bool' => options[:b]
      }
    end

    if options[:f]
      date_string = options[:f]
      if date_string =~ / (to|through|thru|(un)?til|-+) /
        dates = date_string.split(/ (to|through|thru|(un)?til|-+) /)
        start = wwid.chronify(dates[0])
        finish = wwid.chronify(dates[2])
      else
        start = wwid.chronify(date_string)
        finish = false
      end
      exit_now! 'Unrecognized date string' unless start
      dates = [start, finish]
    end

    options[:t] = true if options[:totals]

    tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

    options[:sort_tags] = options[:tag_sort] =~ /^n/i
    opts = {
      age: options[:a],
      count: options[:c].to_i,
      date_filter: dates,
      highlight: true,
      only_timed: options[:only_timed],
      order: options[:s],
      output: options[:output],
      section: section,
      sort_tags: options[:sort_tags],
      tag_filter: tag_filter,
      tags_color: tags_color,
      times: options[:t],
      totals: options[:totals]
    }
    puts wwid.list_section(opts)
  end
end

desc 'Search for entries'
long_desc <<~'EODESC'
  Search all sections (or limit to a single section) for entries matching text or regular expression. Normal strings are fuzzy matched.

  To search with regular expressions, single quote the string and surround with slashes: `doing search '/\bm.*?x\b/'`
EODESC

arg_name 'SEARCH_PATTERN'
command [:grep, :search] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.desc 'Only show items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: false

  c.action do |_global_options, options, args|
    tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

    section = wwid.guess_section(options[:s]) if options[:s]

    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    opts = {
      highlight: true,
      only_timed: options[:only_timed],
      output: options[:output],
      search: args.join(' '),
      section: section,
      sort_tags: options[:sort_tags],
      tags_color: tags_color,
      times: options[:t],
      totals: options[:totals]
    }

    puts wwid.list_section(opts)
  end
end

desc 'List recent entries'
default_value 10
arg_name 'COUNT'
command :recent do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.action do |global_options, options, args|
    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    unless global_options[:version]
      count = args.empty? ? 10 : args[0].to_i
      options[:t] = true if options[:totals]
      options[:sort_tags] = options[:tag_sort] =~ /^n/i
      tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

      opts = {
        sort_tags: options[:sort_tags],
        tags_color: tags_color,
        times: options[:t],
        totals: options[:totals]
      }

      puts wwid.recent(count, section.cap_first, opts)

    end
  end
end

desc 'List entries from today'
command :today do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i

  c.action do |_global_options, options, _args|
    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    puts wwid.today(options[:t], options[:output],
                    { totals: options[:totals], section: options[:s], sort_tags: options[:sort_tags] }).chomp
  end
end

desc 'List entries for a date'
long_desc %(Date argument can be natural language. "thursday" would be interpreted as "last thursday,"
and "2d" would be interpreted as "two days ago." If you use "to" or "through" between two dates,
it will create a range.)
arg_name 'DATE_STRING'
command :on do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i

  c.action do |_global_options, options, args|
    exit_now! 'Missing date argument' if args.empty?

    date_string = args.join(' ')

    if date_string =~ / (to|through|thru) /
      dates = date_string.split(/ (to|through|thru) /)
      start = wwid.chronify(dates[0])
      finish = wwid.chronify(dates[2])
    else
      start = wwid.chronify(date_string)
      finish = false
    end

    exit_now! 'Unrecognized date string' unless start

    message = "Date interpreted as #{start}"
    message += " to #{finish}" if finish
    wwid.results.push(message)

    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    puts wwid.list_date([start, finish], options[:s], options[:t], options[:output],
                        { totals: options[:totals], sort_tags: options[:sort_tags] }).chomp
  end
end

desc 'List entries from yesterday'
command :yesterday do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.action do |_global_options, options, _args|
    options[:sort_tags] = options[:tag_sort] =~ /^n/i
    puts wwid.yesterday(options[:s], options[:t], options[:o],
                        { totals: options[:totals], sort_tags: options[:sort_tags] }).chomp
  end
end

desc 'Show the last entry, optionally edit'
command :last do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Tag filter, combine multiple tags with a comma.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: /(and|or|not)/i, default_value: 'AND'

  c.desc 'Search filter, surround with slashes for regex (/query/)'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.action do |_global_options, options, _args|
    raise '--tag and --search cannot be used together' if options[:tag] && options[:search]

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].split(/ *, */).map { |t| t.strip.sub(/^@/, '') }
      options[:bool] = options[:bool] =~ /^(and|or|not)$/i ? options[:bool].upcase : 'AND'
    end

    if options[:e]
      wwid.edit_last(section: options[:s], options: { search: options[:search], tag: tags, tag_bool: options[:bool] })
    else
      puts wwid.last(times: true, section: options[:s],
                     options: { search: options[:search], tag: tags, tag_bool: options[:bool] }).strip
    end
  end
end

desc 'List sections'
command :sections do |c|
  c.desc 'List in single column'
  c.switch %i[c column], default_value: false

  c.action do |_global_options, options, _args|
    joiner = options[:c] ? "\n" : "\t"
    print wwid.sections.join(joiner)
  end
end

desc 'Select a section to display from a menu'
command :choose do |c|
  c.action do |_global_options, _options, _args|
    section = wwid.choose_section
    puts wwid.list_section({ section: section.cap_first, count: 0 })
  end
end

desc 'Add a new section to the "doing" file'
arg_name 'SECTION_NAME'
command :add_section do |c|
  c.action do |_global_options, _options, args|
    raise "Section #{args[0]} already exists" if wwid.sections.include?(args[0])

    wwid.add_section(args[0].cap_first)
    wwid.write(wwid.doing_file)
  end
end

desc 'List available color variables for configuration templates and views'
command :colors do |c|
  c.action do |_global_options, _options, _args|
    clrs = wwid.colors
    bgs = []
    fgs = []
    clrs.each do |k, v|
      if k =~ /bg/
        bgs.push("#{v}    #{clrs['default']} <-- #{k}")
      else
        fgs.push("#{v}XXXX#{clrs['default']} <-- #{k}")
      end
    end
    puts fgs.join("\n")
    puts bgs.join("\n")
  end
end

desc 'Display a user-created view'
arg_name 'VIEW_NAME'
command :view do |c|
  c.desc 'Section (override view settings)'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc 'Count to display (override view settings)'
  c.arg_name 'COUNT'
  c.flag %i[c count], must_match: /^\d+$/, type: Integer

  c.desc 'Output to export format (csv|html|json|template|timeline)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], must_match: /^(template|html|csv|json|timeline)$/i

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: true

  c.desc 'Include colors in output'
  c.switch [:color], default_value: true, negatable: true

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] if wwid.config.key?('tag_sort')
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(name|time)$/i, default_value: default

  c.desc 'Only show items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: true

  c.action do |_global_options, options, args|
    title = if args.empty?
              wwid.choose_view
            else
              wwid.guess_view(args[0])
            end

    section = wwid.guess_section(options[:s]) || options[:s].cap_first if options[:s]

    view = wwid.get_view(title)
    if view
      only_timed = if (view.key?('only_timed') && view['only_timed']) || options[:only_timed]
                     true
                   else
                     false
                   end

      template = view.key?('template') ? view['template'] : nil
      format = view.key?('date_format') ? view['date_format'] : nil
      tags_color = view.key?('tags_color') ? view['tags_color'] : nil
      tag_filter = false
      if view.key?('tags') && !(view['tags'].nil? || view['tags'].empty?)
        tag_filter = { 'tags' => [], 'bool' => 'OR' }
        tag_filter['tags'] = if view['tags'].instance_of?(Array)
                               view['tags'].map(&:strip)
                             else
                               view['tags'].gsub(/[, ]+/, ' ').split(' ').map(&:strip)
                             end
        tag_filter['bool'] = view.key?('tags_bool') && !view['tags_bool'].nil? ? view['tags_bool'].upcase : 'OR'
      end

      # If the -o/--output flag was specified, override any default in the view template
      options[:o] ||= view.key?('output_format') ? view['output_format'] : 'template'

      count = if options[:c]
                options[:c]
              else
                view.key?('count') ? view['count'] : 10
              end
      section = if options[:s]
                  section
                else
                  view.key?('section') ? view['section'] : wwid.current_section
                end
      order = view.key?('order') ? view['order'] : 'asc'

      options[:t] = true if options[:totals]
      options[:output]&.downcase!
      options[:sort_tags] = options[:tag_sort] =~ /^n/i

      opts = {
        count: count,
        format: format,
        highlight: options[:color],
        only_timed: only_timed,
        order: order,
        output: options[:o],
        section: section,
        sort_tags: options[:sort_tags],
        tag_filter: tag_filter,
        tags_color: tags_color,
        template: template,
        times: options[:t],
        totals: options[:totals]
      }

      puts wwid.list_section(opts)
    elsif title.instance_of?(FalseClass)
      exit_now! 'Cancelled'
    else
      raise "View #{title} not found in config"
    end
  end
end

desc 'List available custom views'
command :views do |c|
  c.desc 'List in single column'
  c.switch %i[c column], default_value: false

  c.action do |_global_options, options, _args|
    joiner = options[:c] ? "\n" : "\t"
    print wwid.views.join(joiner)
  end
end

desc 'Move entries between sections'
arg_name 'SECTION_NAME'
default_value wwid.current_section
command :archive do |c|
  c.desc 'Count to keep (ignored if archiving by tag)'
  c.arg_name 'COUNT'
  c.flag %i[k keep], default_value: 5, must_match: /^\d+$/, type: Integer

  c.desc 'Move entries to'
  c.arg_name 'SECTION_NAME'
  c.flag %i[t to], default_value: 'Archive'

  c.desc 'Tag filter, combine multiple tags with a comma. Added for compatibility with other commands.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND|OR|NOT)'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: /(and|or|not)/i, default_value: 'AND'

  c.action do |_global_options, options, args|
    if args.empty?
      section = wwid.current_section
      tags = []
    elsif args[0] =~ /^@\S+/
      section = 'all'
      tags = args.map { |t| t.sub(/^@/, '').strip }
    else
      section = args[0].cap_first
      tags = args.length > 1 ? args[1..].map { |t| t.sub(/^@/, '').strip } : nil
    end

    tags.concat(options[:tag].split(/ *, */).map { |t| t.sub(/^@/, '').strip }) if options[:tag]

    wwid.archive(section, options[:keep], options[:to], tags, options[:bool])
  end
end

desc 'Open the "doing" file in an editor'
long_desc "`doing open` defaults to using the editor_app setting in #{wwid.config_file} (#{wwid.config.key?('editor_app') ? wwid.config['editor_app'] : 'not set'})"
command :open do |c|
  if `uname` =~ /Darwin/
    c.desc 'Open with app name'
    c.arg_name 'APP_NAME'
    c.flag [:a]

    c.desc 'Open with app bundle id'
    c.arg_name 'BUNDLE_ID'
    c.flag [:b]
  end
  c.desc "Open with $EDITOR (#{ENV['EDITOR']})"
  c.switch %i[e editor], negatable: false, default_value: false

  c.action do |_global_options, options, _args|
    params = options.dup
    params.delete_if do |k, v|
      k.instance_of?(String) || v.nil? || v == false
    end
    if `uname` =~ /Darwin/
      if options[:a]
        system %(open -a "#{options[:a]}" "#{File.expand_path(wwid.doing_file)}")
      elsif options[:b]
        system %(open -b "#{options[:b]}" "#{File.expand_path(wwid.doing_file)}")
      elsif options[:e]
        raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

        system %($EDITOR "#{File.expand_path(wwid.doing_file)}")
      elsif wwid.config.key?('editor_app') && !wwid.config['editor_app'].nil?
        system %(open -a "#{wwid.config['editor_app']}" "#{File.expand_path(wwid.doing_file)}")
      else
        system %(open "#{File.expand_path(wwid.doing_file)}")
      end

    else
      raise 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      system %($EDITOR "#{File.expand_path(wwid.doing_file)}")
    end
  end
end

desc 'Edit the configuration file'
command :config do |c|
  c.desc 'Editor to use'
  c.arg_name 'EDITOR'
  c.flag %i[e editor], default_value: nil

  if `uname` =~ /Darwin/
    c.desc 'Application to use'
    c.arg_name 'APP_NAME'
    c.flag [:a]

    c.desc 'Application bundle id to use'
    c.arg_name 'BUNDLE_ID'
    c.flag [:b]

    c.desc "Use the config_editor_app defined in ~/.doingrc (#{wwid.config.key?('config_editor_app') ? wwid.config['config_editor_app'] : 'config_editor_app not set'})"
    c.switch [:x]
  end

  c.action do |_global_options, options, _args|
    if `uname` =~ /Darwin/
      if options[:x]
        `open -a "#{wwid.config['config_editor_app']}" "#{wwid.config_file}"`
      elsif options[:a] || options[:b]
        if options[:a]
          `open -a "#{options[:a]}" "#{wwid.config_file}"`
        elsif options[:b]
          `open -b #{options[:b]} "#{wwid.config_file}"`
        end
      else
        raise 'No EDITOR variable defined in environment' if options[:e].nil? && ENV['EDITOR'].nil?

        editor = options[:e].nil? ? ENV['EDITOR'] : options[:e]
        system %(#{editor} "#{wwid.config_file}")
      end
    else
      raise 'No EDITOR variable defined in environment' if options[:e].nil? && ENV['EDITOR'].nil?

      editor = options[:e].nil? ? ENV['EDITOR'] : options[:e]
      system %(#{editor} "#{wwid.config_file}")
    end
  end
end

desc 'Undo the last change to the doing_file'
command :undo do |c|
  c.desc 'Specify alternate doing file'
  c.arg_name 'PATH'
  c.flag %i[f file], default_value: wwid.doing_file

  c.action do |_global_options, options, _args|
    file = options[:f] || wwid.doing_file
    wwid.restore_backup(file)
  end
end

pre do |global, _command, _options, _args|
  if global[:config_file] && global[:config_file] != wwid.config_file
    wwid.config_file = global[:config_file]
    wwid.configure({ ignore_local: true })
    # wwid.results.push("Override config file #{wwid.config_file}")
  end

  if global[:doing_file]
    wwid.init_doing_file(global[:doing_file])
  else
    wwid.init_doing_file
  end

  wwid.auto_tag = !global[:noauto]

  wwid.config[:include_notes] = false unless global[:notes]

  $stdout.puts "doing v#{Doing::VERSION}" if global[:version]

  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global, _command, _options, _args|
  # Use skips_post before a command to skip this
  # block on that command only
  if global[:stdout]
    $stdout.print wwid.results.join("\n")
  else
    warn wwid.results.join("\n")
  end
end

on_error do |_exception|
  # puts exception.message
  true
end

exit run(ARGV)
