#!/usr/bin/env ruby -W1
# frozen_string_literal: true

$LOAD_PATH.unshift File.join(__dir__, '..', 'lib')
require 'gli'
require 'doing'
require 'tempfile'
require 'pp'

def class_exists?(class_name)
  klass = Module.const_get(class_name)
  klass.is_a?(Class)
rescue NameError
  false
end

if class_exists? 'Encoding'
  Encoding.default_external = Encoding::UTF_8 if Encoding.respond_to?('default_external')
  Encoding.default_internal = Encoding::UTF_8 if Encoding.respond_to?('default_internal')
end

include GLI::App
include Doing::Errors
version Doing::VERSION
hide_commands_without_desc true


REGEX_BOOL = /^(?:and|all|any|or|not|none)$/i
REGEX_SORT_ORDER = /^(?:a(?:sc)?|d(?:esc)?)$/i

InvalidExportType = Class.new(RuntimeError)
MissingConfigFile = Class.new(RuntimeError)

colors = Doing::Color
wwid = Doing::WWID.new

wwid.user_home = if Dir.respond_to?('home')
                   Dir.home
                 else
                   File.expand_path('~')
                 end

Doing.logger.log_level = :info

if ENV['DOING_LOG_LEVEL'] || ENV['DOING_DEBUG'] || ENV['DOING_QUIET'] || ENV['DOING_VERBOSE'] || ENV['DOING_PLUGIN_DEBUG']
  # Quiet always wins
  if ENV['DOING_QUIET'] && ENV['DOING_QUIET'].truthy?
    Doing.logger.log_level = :error
  elsif (ENV['DOING_PLUGIN_DEBUG'] && ENV['DOING_PLUGIN_DEBUG'].truthy?)
    Doing.logger.log_level = :debug
  elsif (ENV['DOING_DEBUG'] && ENV['DOING_DEBUG'].truthy?)
    Doing.logger.log_level = :debug
  elsif ENV['DOING_LOG_LEVEL']
    Doing.logger.log_level = ENV['DOING_LOG_LEVEL']
  end
end

if ENV['DOING_CONFIG']
  cf = File.expand_path(ENV['DOING_CONFIG'])
  raise MissingConfigFile, "$DOING_CONFIG not found (#{ENV['DOING_CONFIG']})" unless File.exist?(cf)

  wwid.config_file = cf
  wwid.config = nil
  wwid.configure({ ignore_local: true })
else
  wwid.configure
end

program_desc 'A CLI for a What Was I Doing system'

default_command :recent
# sort_help :manually

desc 'Output notes if included in the template'
switch [:notes], default_value: true, negatable: true

desc 'Send results report to STDOUT instead of STDERR'
switch [:stdout], default_value: false, negatable: false

desc 'Use a pager when output is longer than screen'
switch %i[p pager], default_value: wwid.config['paginate']

desc 'Answer yes/no menus with default option'
switch [:default], default_value: false

desc 'Exclude auto tags and default tags'
switch %i[x noauto], default_value: false, negatable: false

desc 'Colored output'
switch %i[color], default_value: true

desc 'Silence info messages'
switch %i[q quiet], default_value: false, negatable: false

desc 'Verbose output'
switch %i[verbose debug], default_value: false, negatable: false

desc 'Use a specific configuration file. Deprecated, set $DOING_CONFIG instead.'
flag [:config_file], default_value: wwid.config_file

desc 'Specify a different doing_file'
flag %i[f doing_file]

desc 'Add an entry'
arg_name 'ENTRY'
command %i[now next] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Backdate start time [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Timed entry, marks last entry in section as @done'
  c.switch %i[f finish_last], negatable: false, default_value: false

  c.desc 'Include a note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  # c.desc "Edit entry with specified app"
  # c.arg_name 'editor_app'
  # # c.flag [:a, :app]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back], guess: :begin)

      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    else
      options[:section] = wwid.current_section
    end

    if options[:e] || (args.empty? && $stdin.stat.size.zero?)
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = ''
      input += args.join(' ') unless args.empty?
      input = wwid.fork_editor(input).strip

      raise Doing::Errors::EmptyInput, 'No content' if input.empty?

      title, note = wwid.format_input(input)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    elsif args.length.positive?
      title, note = wwid.format_input(args.join(' '))
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      input = $stdin.read
      title, note = wwid.format_input(input)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, section, { note: note, back: date, timed: options[:f] })
      wwid.write(wwid.doing_file)
    else
      raise Doing::Errors::EmptyInput, 'You must provide content when creating a new entry'
    end
  end
end

desc 'Add a note to the last entry'
long_desc %(
  If -r is provided with no other arguments, the last note is removed.
  If new content is specified through arguments or STDIN, any previous
  note will be replaced with the new one.

  Use -e to load the last entry in a text editor where you can append a note.
)
arg_name 'NOTE_TEXT'
command :note do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc "Replace/Remove last entry's note (default append)"
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Add/remove note from last entry matching tag'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Add/remove note from last entry matching search filter, surround with slashes for regex (e.g. "/query.*/"), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.action do |_global_options, options, args|
    if options[:section]
      options[:section] = wwid.guess_section(options[:section]) || options[:section].cap_first
    end


    options[:tag_bool] = options[:bool].normalize_bool

    last_entry = wwid.last_entry(options)

    unless last_entry
      Doing.logger.warn('Not found:', 'No entry matching parameters was found.')
      return
    end

    last_note = last_entry.note || Doing::Note.new
    new_note = Doing::Note.new

    if options[:e] || (args.empty? && $stdin.stat.size.zero? && !options[:r])
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = !args.empty? ? args.join(' ') : ''

      if options[:remove]
        prev_input = Doing::Note.new
      else
        prev_input = last_entry.note || Doing::Note.new
      end

      input = prev_input.add(input)

      input = wwid.fork_editor([last_entry.title, '### Edit below this line', input.to_s].join("\n")).strip
      _title, note = wwid.format_input(input)
      options[:remove] = true
      new_note.add(note)
    elsif !args.empty?
      new_note.add(args.join(' '))
    elsif $stdin.stat.size.positive?
      new_note.add($stdin.read)
    else
      raise Doing::Errors::EmptyInput, 'You must provide content when adding a note' unless options[:remove]
    end

    if last_note.equal?(new_note)
      Doing.logger.debug('Skipped:', 'No note change')
    else
      last_note.add(new_note, replace: options[:remove])
      Doing.logger.info('Entry updated:', last_entry.title)
    end
    # new_entry = Doing::Item.new(last_entry.date, last_entry.title, last_entry.section, new_note)

    wwid.write(wwid.doing_file)
  end
end

desc 'Finish any running @meanwhile tasks and optionally create a new one'
arg_name 'ENTRY'
command :meanwhile do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Archive previous @meanwhile entry'
  c.switch %i[a archive], default_value: false

  c.desc 'Backdate start date for new entry to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back], guess: :begin)

      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    else
      section = wwid.current_section
    end
    input = ''

    if options[:e]
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input += args.join(' ') unless args.empty?
      input = wwid.fork_editor(input).strip
    elsif !args.empty?
      input = args.join(' ')
    elsif $stdin.stat.size.positive?
      input = $stdin.read
    end

    if input && !input.empty?
      input, note = wwid.format_input(input)
    else
      input = nil
      note = []
    end

    if options[:n]
      note.push(options[:n])
    elsif note.empty?
      note = nil
    end

    wwid.stop_start('meanwhile', { new_item: input, back: date, section: section, archive: options[:a], note: note })
    wwid.write(wwid.doing_file)
  end
end

desc 'Output HTML, CSS, and Markdown (ERB) templates for customization'
long_desc %(
  Templates are printed to STDOUT for piping to a file.
  Save them and use them in the configuration file under html_template.

  Example `doing template haml > ~/styles/my_doing.haml`
)
arg_name 'TYPE', must_match: Doing::Plugins.template_regex
command :template do |c|
  c.desc 'List all available templates'
  c.switch %i[l list]

  c.desc 'List in single column for completion'
  c.switch %i[c]

  c.action do |_global_options, options, args|
    if options[:list] || options[:c]
      if options[:c]
        $stdout.print Doing::Plugins.plugin_templates.join("\n")
      else
        $stdout.puts "Available templates: #{Doing::Plugins.plugin_templates.join(', ')}"
      end
      return
    end

    raise Doing::Errors::InvalidPluginType, "No type specified, use `doing template [#{Doing::Plugins.plugin_templates.join('|')}]`" if args.empty?

    $stdout.puts Doing::Plugins.template_for_trigger(args[0])

    # case args[0]
    # when /html|haml/i
    #   $stdout.puts wwid.haml_template
    # when /css/i
    #   $stdout.puts wwid.css_template
    # when /markdown|md|erb/i
    #   $stdout.puts wwid.markdown_template
    # else
    #   exit_now! 'Invalid type specified, must be HAML or CSS'
    # end
  end
end

desc 'Display an interactive menu to perform operations'
long_desc 'List all entries and select with typeahead fuzzy matching.

Multiple selections are allowed, hit tab to add the highlighted entry to the
selection, and use ctrl-a to select all visible items. Return processes the
selected entries.'
command :select do |c|
  c.desc 'Select from a specific section'
  c.arg_name 'SECTION'
  c.flag %i[s section]

  c.desc 'Tag selected entries'
  c.arg_name 'TAG'
  c.flag %i[t tag]

  c.desc 'Reverse -c, -f, --flag, and -t (remove instead of adding)'
  c.switch %i[r remove], negatable: false

  # c.desc 'Add @done to selected item(s), using start time of next item as the finish time'
  # c.switch %i[a auto], negatable: false, default_value: false

  c.desc 'Archive selected items'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc 'Move selected items to section'
  c.arg_name 'SECTION'
  c.flag %i[m move]

  c.desc 'Initial search query for filtering. Matching is fuzzy. For exact matching, start query with a single quote, e.g. `--query "\'search"'
  c.arg_name 'QUERY'
  c.flag %i[q query search]

  c.desc 'Use --no-menu to skip the interactive menu. Use with --query to filter items and act on results automatically. Test with `--output doing` to preview matches.'
  c.switch %i[menu], negatable: true, default_value: true

  c.desc 'Cancel selected items (add @done without timestamp)'
  c.switch %i[c cancel], negatable: false, default_value: false

  c.desc 'Delete selected items'
  c.switch %i[d delete], negatable: false, default_value: false

  c.desc 'Edit selected item(s)'
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Add @done with current time to selected item(s)'
  c.switch %i[f finish], negatable: false, default_value: false

  c.desc 'Add flag to selected item(s)'
  c.switch %i[flag], negatable: false, default_value: false

  c.desc 'Perform action without confirmation.'
  c.switch %i[force], negatable: false, default_value: false

  c.desc 'Save selected entries to file using --output format'
  c.arg_name 'FILE'
  c.flag %i[save_to]

  c.desc "Output entries to format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    raise Doing::Errors::InvalidArgument, '--no-menu requires --query' if !options[:menu] && !options[:query]

    wwid.interactive(options)
  end
end

desc 'Add an item to the Later section'
arg_name 'ENTRY'
command :later do |c|
  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Backdate start time to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, args|
    if options[:back]
      date = wwid.chronify(options[:back], guess: :begin)
      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string' if date.nil?
    else
      date = Time.now
    end

    if options[:editor] || (args.empty? && $stdin.stat.size.zero?)
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      input = args.empty? ? '' : args.join(' ')
      input = wwid.fork_editor(input).strip
      raise Doing::Errors::EmptyInput, 'No content' unless input && !input.empty?

      title, note = wwid.format_input(input)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif !args.empty?
      title, note = wwid.format_input(args.join(' '))
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      note.push(options[:n]) if options[:n]
      wwid.add_item(title.cap_first, 'Later', { note: note, back: date })
      wwid.write(wwid.doing_file)
    else
      raise Doing::Errors::EmptyInput, 'You must provide content when creating a new entry'
    end
  end
end

desc 'Add a completed item with @done(date). No argument finishes last entry.'
arg_name 'ENTRY'
command %i[done did] do |c|
  c.desc 'Remove @done tag'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Include date'
  c.switch [:date], negatable: true, default_value: true

  c.desc 'Immediately archive the entry'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc %(Set finish date to specific date/time (natural langauge parsed, e.g. --at=1:30pm).
  If used, ignores --back. Used with --took, backdates start date)
  c.arg_name 'DATE_STRING'
  c.flag [:at]

  c.desc 'Backdate start date by interval [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc %(Set completion date to start date plus interval (XX[mhd] or HH:MM).
  If used without the --back option, the start date will be moved back to allow
  the completion date to be the current time.)
  c.arg_name 'INTERVAL'
  c.flag %i[t took]

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc "Edit entry with #{ENV['EDITOR']} (with no arguments, edits the last entry)"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Include a note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.desc 'Finish last entry not already marked @done'
  c.switch %i[u unfinished], negatable: false, default_value: false

  # c.desc "Edit entry with specified app"
  # c.arg_name 'editor_app'
  # # c.flag [:a, :app]

  c.action do |_global_options, options, args|
    took = 0
    donedate = nil

    if options[:took]
      took = wwid.chronify_qty(options[:took])
      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string for --took' if took.nil?
    end

    if options[:back]
      date = wwid.chronify(options[:back], guess: :begin)
      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string for --back' if date.nil?
    else
      date = options[:took] ? Time.now - took : Time.now
    end

    if options[:at]
      finish_date = wwid.chronify(options[:at], guess: :begin)
      raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string for --at' if finish_date.nil?

      date = options[:took] ? finish_date - took : finish_date
    elsif options[:took]
      finish_date = date + took
    elsif options[:back]
      finish_date = date
    else
      finish_date = Time.now
    end

    if options[:date]
      donedate = finish_date.strftime('%F %R')
    end

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    else
      section = wwid.current_section
    end

    note = Doing::Note.new
    note.add(options[:note]) if options[:note]

    if options[:editor]
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?
      is_new = false

      if args.empty?
        last_entry = wwid.filter_items([], opt: {unfinished: options[:unfinished], section: section, count: 1, age: 'new'}).max_by { |item| item.date }

        unless last_entry
          Doing.logger.debug('Skipped:', options[:unfinished] ? 'No unfinished entry' : 'Last entry already @done')
          raise Doing::Errors::NoResults, 'No results'
        end

        old_entry = last_entry.dup
        last_entry.note.add(note)
        input = [last_entry.title, last_entry.note.to_s].join("\n")
      else
        is_new = true
        input = [args.join(' '), note.to_s].join("\n")
      end

      input = wwid.fork_editor(input).strip
      raise Doing::Errors::EmptyInput, 'No content' unless input && !input.empty?

      title, note = wwid.format_input(input)
      new_entry = Doing::Item.new(date, title, section, note)
      new_entry.tag('done', value: donedate)

      if (is_new)
        wwid.content[section][:items].push(new_entry)
      else
        wwid.update_item(old_entry, new_entry)
      end

      if options[:a]
        wwid.move_item(new_entry, 'Archive', label: true)
      end

      wwid.write(wwid.doing_file)
    elsif args.empty? && $stdin.stat.size.zero?
      if options[:r]
        wwid.tag_last({ tags: ['done'], count: 1, section: section, remove: true })
      else
        note = options[:note] ? Doing::Note.new(options[:note]) : nil
        opt = {
          archive: options[:a],
          back: finish_date,
          count: 1,
          date: options[:date],
          note: note,
          section: section,
          tags: ['done'],
          took: took == 0 ? nil : took,
          unfinished: options[:unfinished]
        }
        wwid.tag_last(opt)
      end
    elsif !args.empty?
      note = Doing::Note.new(options[:note])
      title, new_note = wwid.format_input([args.join(' '), note.to_s].join("\n"))
      title.chomp!
      section = 'Archive' if options[:a]
      new_entry = Doing::Item.new(date, title, section, new_note)
      new_entry.tag('done', value: donedate)
      wwid.content[section][:items].push(new_entry)
      wwid.write(wwid.doing_file)
    elsif $stdin.stat.size.positive?
      title, note = wwid.format_input($stdin.read)
      note.add(options[:note]) if options[:note]
      title.tag!('done', value: donedate)
      section = options[:a] ? 'Archive' : section
      new_entry = Doing::Item.new(date, title, section, note)
      wwid.content[section][:items].push(new_entry)
      wwid.write(wwid.doing_file)
    else
      raise Doing::Errors::EmptyInput, 'You must provide content when creating a new entry'
    end
  end
end

desc 'End last X entries with no time tracked'
long_desc 'Adds @done tag without datestamp so no elapsed time is recorded. Alias for `doing finish --no-date`.'
arg_name 'COUNT'
command :cancel do |c|
  c.desc 'Archive entries'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc 'Cancel the last X entries containing TAG. Separate multiple tags with comma (--tag=tag1,tag2)'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc 'Cancel last entry (or entries) not already marked @done'
  c.switch %i[u unfinished], negatable: false, default_value: false

  c.action do |_global_options, options, args|
    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    else
      section = wwid.current_section
    end

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].to_tags
    end

    raise Doing::Errors::InvalidArgument, 'Only one argument allowed' if args.length > 1

    raise Doing::Errors::InvalidArgument, 'Invalid argument (specify number of recent items to mark @done)' unless args.empty? || args[0] =~ /\d+/

    count = args[0] ? args[0].to_i : 1
    opts = {
      archive: options[:a],
      count: count,
      date: false,
      section: section,
      sequential: false,
      tag: tags,
      tag_bool: options[:bool].normalize_bool,
      tags: ['done'],
      unfinished: options[:unfinished]
    }
    wwid.tag_last(opts)
  end
end

desc 'Mark last X entries as @done'
long_desc 'Marks the last X entries with a @done tag and current date. Does not alter already completed entries.'
arg_name 'COUNT'
command :finish do |c|
  c.desc 'Include date'
  c.switch [:date], negatable: true, default_value: true

  c.desc 'Backdate completed date to date string [4pm|20m|2h|yesterday noon]'
  c.arg_name 'DATE_STRING'
  c.flag %i[b back]

  c.desc 'Set the completed date to the start date plus XX[hmd]'
  c.arg_name 'INTERVAL'
  c.flag %i[t took]

  c.desc %(Set finish date to specific date/time (natural langauge parsed, e.g. --at=1:30pm). If used, ignores --back.)
  c.arg_name 'DATE_STRING'
  c.flag [:at]

  c.desc 'Finish the last X entries containing TAG.
  Separate multiple tags with comma (--tag=tag1,tag2), combine with --bool'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Finish the last X entries matching search filter, surround with slashes for regex (e.g. "/query.*/"), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc 'Remove done tag'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Finish last entry (or entries) not already marked @done'
  c.switch %i[u unfinished], negatable: false, default_value: false

  c.desc %(Auto-generate finish dates from next entry's start time.
  Automatically generate completion dates 1 minute before next item (in any section) began.
  --auto overrides the --date and --back parameters.)
  c.switch [:auto], negatable: false, default_value: false

  c.desc 'Archive entries'
  c.switch %i[a archive], negatable: false, default_value: false

  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.action do |_global_options, options, args|
    unless options[:auto]
      if options[:took]
        took = wwid.chronify_qty(options[:took])
        raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string for --took' if took.nil?
      end

      raise Doing::Errors::InvalidArgument, '--back and --took can not be used together' if options[:back] && options[:took]

      raise Doing::Errors::InvalidArgument, '--search and --tag can not be used together' if options[:search] && options[:tag]

      if options[:at]
        finish_date = wwid.chronify(options[:at], guess: :begin)
        raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string for --at' if finish_date.nil?

        date = options[:took] ? finish_date - took : finish_date
      elsif options[:back]
        date = wwid.chronify(options[:back])

        raise Doing::Errors::InvalidTimeExpression, 'Unable to parse date string' if date.nil?
      elsif options[:took]
        date = wwid.chronify_qty(options[:took])
      else
        date = Time.now
      end
    end

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].to_tags
    end

    raise Doing::Errors::InvalidArgument, 'Only one argument allowed' if args.length > 1

    raise Doing::Errors::InvalidArgument, 'Invalid argument (specify number of recent items to mark @done)' unless args.length == 0 || args[0] =~ /\d+/

    count = args[0] ? args[0].to_i : 1

    opts = {
      archive: options[:archive],
      back: date,
      count: count,
      date: options[:date],
      search: options[:search],
      section: options[:section],
      sequential: options[:auto],
      tag: tags,
      tag_bool: options[:bool].normalize_bool,
      tags: ['done'],
      unfinished: options[:unfinished],
      remove: options[:remove]
    }

    wwid.tag_last(opts)
  end
end

desc 'Repeat last entry as new entry'
command %i[again resume] do |c|
  c.desc 'Get last entry from a specific section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Add new entry to section (default: same section as repeated entry)'
  c.arg_name 'SECTION_NAME'
  c.flag [:in]

  c.desc 'Repeat last entry matching tags. Combine multiple tags with a comma.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Repeat last entry matching search. Surround with
  slashes for regex (e.g. "/query/"), start with a single quote for exact match ("\'query").'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean used to combine multiple tags'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc "Edit duplicated entry with #{ENV['EDITOR']} before adding"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Note'
  c.arg_name 'TEXT'
  c.flag %i[n note]

  c.action do |_global_options, options, _args|
    tags = options[:tag].nil? ? [] : options[:tag].to_tags
    opts = options
    opts[:tag] = tags
    opts[:tag_bool] = options[:bool].normalize_bool

    wwid.restart_last(opts)
  end
end

desc 'Add tag(s) to last entry'
long_desc 'Add (or remove) tags from the last entry, or from multiple entries
          (with `--count`), entries matching a search (with `--search`), or entries
          containing another tag (with `--tag`).

          When removing tags with `-r`, wildcards are allowed (`*` to match
          multiple characters, `?` to match a single character). With `--regex`,
          regular expressions will be interpreted instead of wildcards.

          For all tag removals the match is case insensitive by default, but if
          the tag search string contains any uppercase letters, the match will
          become case sensitive automatically.

          Tag name arguments do not need to be prefixed with @.'
arg_name 'TAG', :multiple
command :tag do |c|
  c.desc 'Section'
  c.arg_name 'SECTION_NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'How many recent entries to tag (0 for all)'
  c.arg_name 'COUNT'
  c.flag %i[c count], default_value: 1

  c.desc 'Replace existing tag with tag argument, wildcards (*,?) allowed, or use with --regex'
  c.arg_name 'ORIG_TAG'
  c.flag %i[rename]

  c.desc 'Don\'t ask permission to tag all entries when count is 0'
  c.switch %i[force], negatable: false, default_value: false

  c.desc 'Include current date/time with tag'
  c.switch %i[d date], negatable: false, default_value: false

  c.desc 'Remove given tag(s)'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Interpret tag string as regular expression (with --remove)'
  c.switch %i[regex], negatable: false, default_value: false

  c.desc 'Tag last entry (or entries) not marked @done'
  c.switch %i[u unfinished], negatable: false, default_value: false

  c.desc 'Autotag entries based on autotag configuration in ~/.doingrc'
  c.switch %i[a autotag], negatable: false, default_value: false

  c.desc 'Tag the last X entries containing TAG.
  Separate multiple tags with comma (--tag=tag1,tag2), combine with --bool'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag entries matching search filter, surround with slashes for regex (e.g. "/query.*/"), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.action do |_global_options, options, args|
    raise Doing::Errors::MissingArgument, 'You must specify at least one tag' if args.empty? && !options[:a]

    raise Doing::Errors::InvalidArgument, '--search and --tag can not be used together' if options[:search] && options[:tag]

    section = 'All'

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    end


    if options[:tag].nil?
      search_tags = []
    else
      search_tags = options[:tag].to_tags
    end

    if options[:autotag]
      tags = []
    else
      tags = if args.join('') =~ /,/
               args.join('').split(/,/)
             else
               args.join(' ').split(' ') # in case tags are quoted as one arg
             end

      tags.map! { |tag| tag.sub(/^@/, '').strip }
    end

    count = options[:count].to_i

    if count.zero? && !options[:force]
      if options[:search]
        section_q = ' matching your search terms'
      elsif options[:tag]
        section_q = ' matching your tag search'
      elsif section == 'All'
        section_q = ''
      else
        section_q = " in section #{section}"
      end


      question = if options[:a]
                   "Are you sure you want to autotag all records#{section_q}"
                 elsif options[:r]
                   "Are you sure you want to remove #{tags.join(' and ')} from all records#{section_q}"
                 else
                   "Are you sure you want to add #{tags.join(' and ')} to all records#{section_q}"
                 end

      res = wwid.yn(question, default_response: false)

      exit_now! 'Cancelled' unless res
    end

    options[:count] = count
    options[:section] = section
    options[:tag] = search_tags
    options[:tags] = tags
    options[:tag_bool] = options[:bool].normalize_bool

    wwid.tag_last(options)
  end
end

desc 'Mark last entry as flagged'
command [:mark, :flag] do |c|
  c.desc 'Section'
  c.arg_name 'SECTION_NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'How many recent entries to tag (0 for all)'
  c.arg_name 'COUNT'
  c.flag %i[c count], default_value: 1

  c.desc 'Don\'t ask permission to flag all entries when count is 0'
  c.switch %i[force], negatable: false, default_value: false

  c.desc 'Include current date/time with tag'
  c.switch %i[d date], negatable: false, default_value: false

  c.desc 'Remove flag'
  c.switch %i[r remove], negatable: false, default_value: false

  c.desc 'Flag last entry (or entries) not marked @done'
  c.switch %i[u unfinished], negatable: false, default_value: false

  c.desc 'Flag the last entry containing TAG.
  Separate multiple tags with comma (--tag=tag1,tag2), combine with --bool'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Flag the last entry matching search filter, surround with slashes for regex (e.g. "/query.*/"), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Boolean (AND|OR|NOT) with which to combine multiple tag filters'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.action do |_global_options, options, _args|
    mark = wwid.config['marker_tag'] || 'flagged'

    raise Doing::Errors::InvalidArgument, '--search and --tag can not be used together' if options[:search] && options[:tag]

    section = 'All'

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    end

    if options[:tag].nil?
      search_tags = []
    else
      search_tags = options[:tag].to_tags
    end

    count = options[:count].to_i

    if count.zero? && !options[:force]
      if options[:search]
        section_q = ' matching your search terms'
      elsif options[:tag]
        section_q = ' matching your tag search'
      elsif section == 'All'
        section_q = ''
      else
        section_q = " in section #{section}"
      end


      question = if options[:remove]
                   "Are you sure you want to unflag all entries#{section_q}"
                 else
                   "Are you sure you want to flag all records#{section_q}"
                 end

      res = wwid.yn(question, default_response: false)

      exit_now! 'Cancelled' unless res
    end

    options[:count] = count
    options[:section] = section
    options[:tag] = search_tags
    options[:tags] = [mark]
    options[:tag_bool] = options[:bool].normalize_bool

    wwid.tag_last(options)
  end
end

desc 'List all entries'
long_desc %(
  The argument can be a section name, @tag(s) or both.
  "pick" or "choose" as an argument will offer a section menu.
)
arg_name '[SECTION|@TAGS]'
command :show do |c|
  c.desc 'Tag filter, combine multiple tags with a comma. Added for compatibility with other commands.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND,OR,NOT)'
  c.arg_name 'BOOLEAN'
  c.flag %i[b bool], must_match: REGEX_BOOL, default_value: 'OR'

  c.desc 'Max count to show'
  c.arg_name 'MAX'
  c.flag %i[c count], default_value: 0

  c.desc 'Age (oldest|newest)'
  c.arg_name 'AGE'
  c.flag %i[a age], default_value: 'newest'

  c.desc 'View entries older than date'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.desc 'View entries newer than date'
  c.arg_name 'DATE_STRING'
  c.flag [:after]

  c.desc 'Search filter, surround with slashes for regex (/query/), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Sort order (asc/desc)'
  c.arg_name 'ORDER'
  c.flag %i[s sort], must_match: REGEX_SORT_ORDER, default_value: 'asc'

  c.desc %(
    Date range to show, or a single day to filter date on.
    Date range argument should be quoted. Date specifications can be natural language.
    To specify a range, use "to" or "through": `doing show --from "monday to friday"`
  )
  c.arg_name 'DATE_OR_RANGE'
  c.flag %i[f from]

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)/i, default_value: default

  c.desc 'Tag sort direction (asc|desc)'
  c.arg_name 'DIRECTION'
  c.flag [:tag_order], must_match: REGEX_SORT_ORDER, default_value: 'asc'

  c.desc 'Only show items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: false

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]
  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    tag_filter = false
    tags = []
    if args.length.positive?
      case args[0]
      when /^all$/i
        section = 'All'
        args.shift
      when /^(choose|pick)$/i
        section = wwid.choose_section
        args.shift
      when /^@/
        section = 'All'
      else
        section = wwid.guess_section(args[0])
        raise Doing::Errors::InvalidSection, "No such section: #{args[0]}" unless section

        args.shift
      end
      if args.length.positive?
        args.each do |arg|
          arg.split(/,/).each do |tag|
                        tags.push(tag.strip.sub(/^@/, ''))
                      end
        end
      end
    else
      section = wwid.current_section
    end

    tags.concat(options[:tag].to_tags) if options[:tag]

    unless tags.empty?
      tag_filter = {
        'tags' => tags,
        'bool' => options[:bool].normalize_bool
      }
    end

    if options[:from]

      date_string = options[:from]
      if date_string =~ / (to|through|thru|(un)?til|-+) /
        dates = date_string.split(/ (to|through|thru|(un)?til|-+) /)
        start = wwid.chronify(dates[0], guess: :begin)
        finish = wwid.chronify(dates[2], guess: :end)
      else
        start = wwid.chronify(date_string, guess: :begin)
        finish = false
      end
      raise Doing::Errors::InvalidTimeExpression, 'Unrecognized date string' unless start
      dates = [start, finish]
    end

    options[:times] = true if options[:totals]

    tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

    opt = options.dup

    opt[:sort_tags] = options[:tag_sort] =~ /^n/i
    opt[:count] = options[:count].to_i
    opt[:date_filter] = dates
    opt[:highlight] = true
    opt[:order] = options[:sort].normalize_order
    opt[:section] = section
    opt[:tag] = nil
    opt[:tag_filter] = tag_filter
    opt[:tag_order] = options[:tag_order].normalize_order
    opt[:tags_color] = tags_color

    puts wwid.list_section(opt)
  end
end

desc 'Search for entries'
long_desc <<~'EODESC'
  Search all sections (or limit to a single section) for entries matching text or regular expression. Normal strings are fuzzy matched.

  To search with regular expressions, single quote the string and surround with slashes: `doing search '/\bm.*?x\b/'`
EODESC

arg_name 'SEARCH_PATTERN'
command %i[grep search] do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Constrain search to entries older than date'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.desc 'Constrain search to entries newer than date'
  c.arg_name 'DATE_STRING'
  c.flag [:after]

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.desc 'Only show items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: false

  c.desc 'Display an interactive menu of results to perform further operations'
  c.switch %i[i interactive], default_value: false, negatable: false

  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

    section = wwid.guess_section(options[:section]) if options[:section]

    options[:times] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i
    options[:highlight] = true
    options[:search] = args.join(' ')
    options[:section] = section
    options[:tags_color] = tags_color

    puts wwid.list_section(options)
  end
end

desc 'List recent entries'
default_value 10
arg_name 'COUNT'
command :recent do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.action do |global_options, options, args|
    section = wwid.guess_section(options[:s]) || options[:s].cap_first

    unless global_options[:version]
      if wwid.config['templates']['recent'].key?('count')
        config_count = wwid.config['templates']['recent']['count'].to_i
      else
        config_count = 10
      end
      count = args.empty? ? config_count : args[0].to_i
      options[:t] = true if options[:totals]
      options[:sort_tags] = options[:tag_sort] =~ /^n/i
      tags_color = wwid.config.key?('tags_color') ? wwid.config['tags_color'] : nil

      opts = {
        sort_tags: options[:sort_tags],
        tags_color: tags_color,
        times: options[:t],
        totals: options[:totals]
      }

      Doing::Pager::page wwid.recent(count, section.cap_first, opts)

    end
  end
end

desc 'List entries from today'
command :today do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.desc 'View entries before specified time (e.g. 8am, 12:30pm, 15:00)'
  c.arg_name 'TIME_STRING'
  c.flag [:before]

  c.desc 'View entries after specified time (e.g. 8am, 12:30pm, 15:00)'
  c.arg_name 'TIME_STRING'
  c.flag [:after]

  c.action do |_global_options, options, _args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i
    opt = {
      after: options[:after],
      before: options[:before],
      section: options[:section],
      sort_tags: options[:sort_tags],
      totals: options[:totals]
    }
    puts wwid.today(options[:times], options[:output], opt).chomp
  end
end

desc 'List entries for a date'
long_desc %(Date argument can be natural language. "thursday" would be interpreted as "last thursday,"
and "2d" would be interpreted as "two days ago." If you use "to" or "through" between two dates,
it will create a range.)
arg_name 'DATE_STRING'
command :on do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    raise Doing::Errors::MissingArgument, 'Missing date argument' if args.empty?

    date_string = args.join(' ')

    if date_string =~ / (to|through|thru) /
      dates = date_string.split(/ (to|through|thru) /)
      start = wwid.chronify(dates[0], guess: :begin)
      finish = wwid.chronify(dates[2], guess: :end)
    else
      start = wwid.chronify(date_string, guess: :begin)
      finish = false
    end

    raise Doing::Errors::InvalidTimeExpression, 'Unrecognized date string' unless start

    message = "Date interpreted as #{start}"
    message += " to #{finish}" if finish
    Doing.logger.debug(message)

    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    puts wwid.list_date([start, finish], options[:s], options[:t], options[:output],
                        { totals: options[:totals], sort_tags: options[:sort_tags] }).chomp
  end
end

desc 'List entries since a date'
long_desc %(Date argument can be natural language and are always interpreted as being in the past. "thursday" would be interpreted as "last thursday,"
and "2d" would be interpreted as "two days ago.")
arg_name 'DATE_STRING'
command :since do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    raise Doing::Errors::MissingArgument, 'Missing date argument' if args.empty?

    date_string = args.join(' ')

    date_string.sub!(/(day) (\d)/, '\1 at \2')
    date_string.sub!(/(\d+)d( ago)?/, '\1 days ago')

    start = wwid.chronify(date_string, guess: :begin)
    finish = Time.now

    raise Doing::Errors::InvalidTimeExpression, 'Unrecognized date string' unless start

    Doing.logger.debug("Date interpreted as #{start} through the current time")

    options[:t] = true if options[:totals]
    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    puts wwid.list_date([start, finish], options[:s], options[:t], options[:output],
                        { totals: options[:totals], sort_tags: options[:sort_tags] }).chomp
  end
end

desc 'List entries from yesterday'
command :yesterday do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show time totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Sort tags by (name|time)'
  default = 'time'
  default = wwid.config['tag_sort'] || 'name'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i, default_value: default

  c.desc 'View entries before specified time (e.g. 8am, 12:30pm, 15:00)'
  c.arg_name 'TIME_STRING'
  c.flag [:before]

  c.desc 'View entries after specified time (e.g. 8am, 12:30pm, 15:00)'
  c.arg_name 'TIME_STRING'
  c.flag [:after]

  c.desc 'Tag sort direction (asc|desc)'
  c.arg_name 'DIRECTION'
  c.flag [:tag_order], must_match: REGEX_SORT_ORDER, default_value: 'asc'

  c.action do |_global_options, options, _args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    options[:sort_tags] = options[:tag_sort] =~ /^n/i

    opt = {
      after: options[:after],
      before: options[:before],
      sort_tags: options[:sort_tags],
      tag_order: options[:tag_order].normalize_order,
      totals: options[:totals]
    }
    puts wwid.yesterday(options[:section], options[:times], options[:output], opt).chomp
  end
end

desc 'Show the last entry, optionally edit'
command :last do |c|
  c.desc 'Specify a section'
  c.arg_name 'NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc "Edit entry with #{ENV['EDITOR']}"
  c.switch %i[e editor], negatable: false, default_value: false

  c.desc 'Tag filter, combine multiple tags with a comma.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc 'Search filter, surround with slashes for regex (/query/), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.action do |global_options, options, _args|
    raise Doing::Errors::InvalidArgument, '--tag and --search can not be used together' if options[:tag] && options[:search]

    if options[:tag].nil?
      tags = []
    else
      tags = options[:tag].to_tags
      options[:bool] = case options[:bool]
                       when /(any|or)/i
                        :or
                       when /(not|none)/i
                        :not
                       else
                        :and
                       end

    end

    if options[:editor]
      wwid.edit_last(section: options[:s], options: { search: options[:search], tag: tags, tag_bool: options[:bool] })
    else
      Doing::Pager::page wwid.last(times: true, section: options[:s],
                     options: { search: options[:search], tag: tags, tag_bool: options[:bool] }).strip
    end
  end
end

desc 'List sections'
command :sections do |c|
  c.desc 'List in single column'
  c.switch %i[c column], default_value: false

  c.action do |_global_options, options, _args|
    joiner = options[:c] ? "\n" : "\t"
    print wwid.sections.join(joiner)
  end
end

desc 'Select a section to display from a menu'
command :choose do |c|
  c.action do |_global_options, _options, _args|
    section = wwid.choose_section

    puts wwid.list_section({ section: section.cap_first, count: 0 }) if section
  end
end

desc 'Add a new section to the "doing" file'
arg_name 'SECTION_NAME'
command :add_section do |c|
  c.action do |_global_options, _options, args|
    raise Doing::Errors::InvalidArgument, "Section #{args[0]} already exists" if wwid.sections.include?(args[0])

    wwid.add_section(args.join(' ').cap_first)
    wwid.write(wwid.doing_file)
  end
end

desc 'List available color variables for configuration templates and views'
command :colors do |c|
  c.action do |_global_options, _options, _args|
    bgs = []
    fgs = []
    colors::attributes.each do |color|
      if color.to_s =~ /bg/
        bgs.push("#{colors.send(color, "    ")}#{colors.default} <-- #{color.to_s}")
      else
        fgs.push("#{colors.send(color, "XXXX")}#{colors.default} <-- #{color.to_s}")
      end
    end
    puts fgs.join("\n")
    puts bgs.join("\n")
  end
end

desc 'List installed plugins'
long_desc %(Lists available plugins, including user-installed plugins.

Export plugins are available with the `--output` flag on commands that support it.

Import plugins are available using `doing import --type PLUGIN`.
)
command :plugins do |c|
  c.desc 'List plugins of type (import, export)'
  c.arg_name 'TYPE'
  c.flag %i[t type], must_match: /^[iea].*$/i, default_value: 'all'

  c.desc 'List in single column for completion'
  c.switch %i[c column], default_value: false

  c.action do |_global_options, options, _args|
    Doing::Plugins.list_plugins(options)
  end
end

desc 'Display a user-created view'
long_desc 'Command line options override view configuration'
arg_name 'VIEW_NAME'
command :view do |c|
  c.desc 'Section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc 'Count to display'
  c.arg_name 'COUNT'
  c.flag %i[c count], must_match: /^\d+$/, type: Integer

  c.desc "Output to export format (#{Doing::Plugins.plugin_names(type: :export)})"
  c.arg_name 'FORMAT'
  c.flag %i[o output]

  c.desc 'Show time intervals on @done tasks'
  c.switch %i[t times], default_value: true, negatable: true

  c.desc 'Show intervals with totals at the end of output'
  c.switch [:totals], default_value: false, negatable: false

  c.desc 'Include colors in output'
  c.switch [:color], default_value: true, negatable: true

  c.desc 'Tag filter, combine multiple tags with a comma.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND,OR,NOT)'
  c.arg_name 'BOOLEAN'
  c.flag %i[b bool], must_match: REGEX_BOOL, default_value: 'OR'

  c.desc 'Search filter, surround with slashes for regex (/query/), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Sort tags by (name|time)'
  c.arg_name 'KEY'
  c.flag [:tag_sort], must_match: /^(?:name|time)$/i

  c.desc 'Tag sort direction (asc|desc)'
  c.arg_name 'DIRECTION'
  c.flag [:tag_order], must_match: REGEX_SORT_ORDER

  c.desc 'View entries older than date'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.desc 'View entries newer than date'
  c.arg_name 'DATE_STRING'
  c.flag [:after]

  c.desc 'Only show items with recorded time intervals (override view settings)'
  c.switch [:only_timed], default_value: false, negatable: false

  c.action do |_global_options, options, args|
    raise InvalidExportType, "Invalid export type: #{options[:output]}" if options[:output] && options[:output] !~ Doing::Plugins.plugin_regex(type: :export)

    raise Doing::Errors::InvalidArgument, '--tag and --search can not be used together' if options[:tag] && options[:search]

    title = if args.empty?
              wwid.choose_view
            else
              wwid.guess_view(args[0])
            end

    if options[:section]
      section = wwid.guess_section(options[:section]) || options[:section].cap_first
    else
      section = wwid.current_section
    end

    view = wwid.get_view(title)
    if view
      page_title = view.key?('title') ? view['title'] : title.cap_first
      only_timed = if (view.key?('only_timed') && view['only_timed']) || options[:only_timed]
                     true
                   else
                     false
                   end

      template = view.key?('template') ? view['template'] : nil
      date_format = view.key?('date_format') ? view['date_format'] : nil
      tags_color = view.key?('tags_color') ? view['tags_color'] : nil
      tag_filter = false
      if options[:tag]
        tag_filter = { 'tags' => [], 'bool' => 'OR' }
        tag_filter['tags'] = options[:tag].gsub(/[, ]+/, ' ').split(' ').map(&:strip)
        tag_filter['bool'] = options[:bool].normalize_bool
      elsif view.key?('tags') && !(view['tags'].nil? || view['tags'].empty?)
        tag_filter = { 'tags' => [], 'bool' => 'OR' }
        tag_filter['tags'] = if view['tags'].instance_of?(Array)
                               view['tags'].map(&:strip)
                             else
                               view['tags'].gsub(/[, ]+/, ' ').split(' ').map(&:strip)
                             end
        tag_filter['bool'] = view.key?('tags_bool') && !view['tags_bool'].nil? ? view['tags_bool'].normalize_bool : :or
      end

      # If the -o/--output flag was specified, override any default in the view template
      options[:output] ||= view.key?('output_format') ? view['output_format'] : 'template'

      count = if options[:c]
                options[:c]
              else
                view.key?('count') ? view['count'] : 10
              end
      section = if options[:s]
                  section
                else
                  view.key?('section') ? view['section'] : wwid.current_section
                end
      order = view.key?('order') ? view['order'].normalize_order : 'asc'

      totals = if options[:totals]
                 true
               else
                 view.key?('totals') ? view['totals'] : false
               end
      tag_order = if options[:tag_order]
                    options[:tag_order].normalize_order
                  else
                    view.key?('tag_order') ? view['tag_order'].normalize_order : 'asc'
                  end

      options[:t] = true if totals
      output_format = options[:output]&.downcase || 'template'

      options[:sort_tags] = if options[:tag_sort]
                              options[:tag_sort] =~ /^n/i ? true : false
                            elsif view.key?('tag_sort')
                              view['tag_sort'] =~ /^n/i ? true : false
                            else
                              false
                            end
      if view.key?('after') && !options[:after]
        options[:after] = view['after']
      end

      if view.key?('before') && !options[:before]
        options[:before] = view['before']
      end

      if view.key?('from')
        date_string = view['from']
        if date_string =~ / (to|through|thru|(un)?til|-+) /
          dates = date_string.split(/ (to|through|thru|(un)?til|-+) /)
          start = wwid.chronify(dates[0], guess: :begin)
          finish = wwid.chronify(dates[2], guess: :end)
        else
          start = wwid.chronify(date_string, guess: :begin)
          finish = false
        end
        raise Doing::Errors::InvalidTimeExpression, 'Unrecognized date string' unless start
        dates = [start, finish]
      end

      opts = options
      opts[:output] = output_format
      opts[:count] = count
      opts[:format] = date_format
      opts[:highlight] = options[:color]
      opts[:only_timed] = only_timed
      opts[:order] = order
      opts[:section] = section
      opts[:tag_filter] = tag_filter
      opts[:tag_order] = tag_order
      opts[:tags_color] = tags_color
      opts[:template] = template
      opts[:totals] = totals
      opts[:page_title] = page_title
      opts[:date_filter] = dates

      puts wwid.list_section(opts)
    elsif title.instance_of?(FalseClass)
      exit_now! 'Cancelled'
    else
      raise Doing::Errors::InvalidView, "View #{title} not found in config"
    end
  end
end

desc 'List available custom views'
command :views do |c|
  c.desc 'List in single column'
  c.switch %i[c column], default_value: false

  c.action do |_global_options, options, _args|
    joiner = options[:c] ? "\n" : "\t"
    print wwid.views.join(joiner)
  end
end

desc 'Move entries between sections'
arg_name 'SECTION_NAME'
default_value wwid.current_section
command :archive do |c|
  c.desc 'How many items to keep (ignored if archiving by tag or search)'
  c.arg_name 'X'
  c.flag %i[k keep], must_match: /^\d+$/, type: Integer

  c.desc 'Move entries to'
  c.arg_name 'SECTION_NAME'
  c.flag %i[t to], default_value: 'Archive'

  c.desc 'Label moved items with @from(SECTION_NAME)'
  c.switch [:label], default_value: true, negatable: true

  c.desc 'Tag filter, combine multiple tags with a comma. Added for compatibility with other commands.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND|OR|NOT)'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc 'Search filter'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Archive entries older than date
    (Flexible date format, e.g. 1/27/2021, 2020-07-19, or Monday 3pm)'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.action do |_global_options, options, args|
    if args.empty?
      section = wwid.current_section
      tags = []
    elsif args[0] =~ /^all/i
      section = 'all'
    elsif args[0] =~ /^@\S+/
      section = 'all'
      tags = args.map { |t| t.sub(/^@/, '').strip }
    else
      section = args[0].cap_first
      tags = args.length > 1 ? args[1..].map { |t| t.sub(/^@/, '').strip } : []
    end

    raise Doing::Errors::InvalidArgument, '--keep and --count can not be used together' if options[:keep] && options[:count]

    tags.concat(options[:tag].to_tags) if options[:tag]

    opts = options
    opts[:bool] = options[:bool].normalize_bool
    opts[:destination] = options[:to]
    opts[:tags] = tags

    wwid.archive(section, opts)
  end
end

desc 'Move entries to archive file'
command :rotate do |c|
  c.desc 'How many items to keep in each section (most recent)'
  c.arg_name 'X'
  c.flag %i[k keep], must_match: /^\d+$/, type: Integer

  c.desc 'Section to rotate'
  c.arg_name 'SECTION_NAME'
  c.flag %i[s section], default_value: 'All'

  c.desc 'Tag filter, combine multiple tags with a comma. Added for compatibility with other commands.'
  c.arg_name 'TAG'
  c.flag [:tag]

  c.desc 'Tag boolean (AND|OR|NOT)'
  c.arg_name 'BOOLEAN'
  c.flag [:bool], must_match: REGEX_BOOL, default_value: 'AND'

  c.desc 'Search filter'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Rotate entries older than date
    (Flexible date format, e.g. 1/27/2021, 2020-07-19, or Monday 3pm)'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.action do |_global_options, options, args|
    if options[:section] && options[:section] !~ /^all$/i
      options[:section] = wwid.guess_section(options[:section])
    end

    options[:bool] = options[:bool].normalize_bool

    wwid.rotate(options)
  end
end

desc 'Open the "doing" file in an editor'
long_desc "`doing open` defaults to using the editor_app setting in #{wwid.config_file} (#{wwid.config.key?('editor_app') ? wwid.config['editor_app'] : 'not set'})"
command :open do |c|
  if `uname` =~ /Darwin/
    c.desc 'Open with app name'
    c.arg_name 'APP_NAME'
    c.flag %i[a app]

    c.desc 'Open with app bundle id'
    c.arg_name 'BUNDLE_ID'
    c.flag %i[b bundle_id]
  end
  c.desc "Open with $EDITOR (#{ENV['EDITOR']})"
  c.switch %i[e editor], negatable: false, default_value: false

  c.action do |_global_options, options, _args|
    params = options.dup
    params.delete_if do |k, v|
      k.instance_of?(String) || v.nil? || v == false
    end
    if `uname` =~ /Darwin/
      if options[:app]
        system %(open -a "#{options[:a]}" "#{File.expand_path(wwid.doing_file)}")
      elsif options[:bundle_id]
        system %(open -b "#{options[:b]}" "#{File.expand_path(wwid.doing_file)}")
      elsif options[:editor]
        raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

        system %($EDITOR "#{File.expand_path(wwid.doing_file)}")
      elsif wwid.config.key?('editor_app') && !wwid.config['editor_app'].nil?
        system %(open -a "#{wwid.config['editor_app']}" "#{File.expand_path(wwid.doing_file)}")
      else
        system %(open "#{File.expand_path(wwid.doing_file)}")
      end

    else
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if ENV['EDITOR'].nil?

      system %($EDITOR "#{File.expand_path(wwid.doing_file)}")
    end
  end
end

desc 'Edit the configuration file'
command :config do |c|
  c.desc 'Editor to use'
  c.arg_name 'EDITOR'
  c.flag %i[e editor], default_value: nil

  c.desc 'Show a config key value. Separate key paths with colons or dots, e.g. "export_templates.html". Use . to output the entire config.'
  c.arg_name 'KEY'
  c.flag %i[d dump]

  c.desc 'Format for --dump (json|yaml|raw)'
  c.arg_name 'FORMAT'
  c.flag %i[o output], default_value: 'yaml', must_match: /^(?:y(?:aml)?|j(?:son)?|r(?:aw)?)$/

  c.desc 'Update config file with missing configuration options'
  c.switch %i[u update], default_value: false, negatable: false

  if `uname` =~ /Darwin/
    c.desc 'Application to use'
    c.arg_name 'APP_NAME'
    c.flag [:a]

    c.desc 'Application bundle id to use'
    c.arg_name 'BUNDLE_ID'
    c.flag [:b]

    c.desc "Use the config_editor_app defined in ~/.doingrc (#{wwid.config.key?('config_editor_app') ? wwid.config['config_editor_app'] : 'config_editor_app not set'})"
    c.switch [:x]
  end

  c.action do |_global_options, options, _args|
    if options[:update]
      wwid.configure({rewrite: true, ignore_local: true})
      Doing.logger.warn("Config file rewritten: #{wwid.config_file}")
      return
    end

    if options[:dump]
      cfg = wwid.config
      unless options[:dump] == '.'
        path = options[:dump].split(/[:.]/)
        cfg = cfg.dig(*path)
      end

      if cfg
        $stdout.puts case options[:output]
                     when /^j/
                       JSON.pretty_generate(cfg)
                     when /^r/
                       cfg
                     else
                       if cfg.is_a?(String)
                         cfg
                       else
                         YAML.dump(cfg)
                       end
                     end
      else
        Doing.logger.log_now(:error, 'Config:', "Key #{options[:dump]} not found")
      end

      return
    end

    if wwid.additional_configs.count.positive?
      choices = [wwid.config_file]
      choices.concat(wwid.additional_configs)
      res = wwid.choose_from(choices.uniq.sort.reverse, sorted: false, prompt: 'Local configs found, select which to edit > ')

      raise Doing::Errors::UserCancelled, 'Cancelled' unless res

      config_file = res.strip || wwid.config_file
    else
      config_file = wwid.config_file
    end

    if `uname` =~ /Darwin/
      if options[:x]
        `open -a "#{wwid.config['config_editor_app']}" "#{config_file}"`
      elsif options[:a] || options[:b]
        if options[:a]
          `open -a "#{options[:a]}" "#{config_file}"`
        elsif options[:b]
          `open -b #{options[:b]} "#{config_file}"`
        end
      else
        raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if options[:e].nil? && ENV['EDITOR'].nil?

        editor = options[:e].nil? ? ENV['EDITOR'] : options[:e]
        system %(#{editor} "#{config_file}")
      end
    else
      raise Doing::Errors::MissingEditor, 'No EDITOR variable defined in environment' if options[:e].nil? && ENV['EDITOR'].nil?

      editor = options[:e].nil? ? ENV['EDITOR'] : options[:e]
      system %(#{editor} "#{config_file}")
    end
  end
end

desc 'Undo the last change to the doing_file'
command :undo do |c|
  c.desc 'Specify alternate doing file'
  c.arg_name 'PATH'
  c.flag %i[f file], default_value: wwid.doing_file

  c.action do |_global_options, options, _args|
    file = options[:f] || wwid.doing_file
    wwid.restore_backup(file)
  end
end

desc 'Import entries from an external source'
long_desc "Imports entries from other sources. Available plugins: #{Doing::Plugins.plugin_names(type: :import, separator: ', ')}"
arg_name 'PATH'
command :import do |c|
  c.desc "Import type (#{Doing::Plugins.plugin_names(type: :import)})"
  c.arg_name 'TYPE'
  c.flag :type, default_value: 'doing'

  c.desc 'Only import items matching search. Surround with slashes for regex (/query/), start with single quote for exact match ("\'query")'
  c.arg_name 'QUERY'
  c.flag [:search]

  c.desc 'Only import items with recorded time intervals'
  c.switch [:only_timed], default_value: false, negatable: false

  c.desc 'Target section'
  c.arg_name 'NAME'
  c.flag %i[s section]

  c.desc 'Tag all imported entries'
  c.arg_name 'TAGS'
  c.flag :tag

  c.desc 'Autotag entries'
  c.switch :autotag, negatable: true, default_value: true

  c.desc 'Prefix entries with'
  c.arg_name 'PREFIX'
  c.flag :prefix

  c.desc 'Import entries older than date'
  c.arg_name 'DATE_STRING'
  c.flag [:before]

  c.desc 'Import entries newer than date'
  c.arg_name 'DATE_STRING'
  c.flag [:after]

  c.desc %(
    Date range to import. Date range argument should be quoted. Date specifications can be natural language.
    To specify a range, use "to" or "through": `--from "monday to friday"` or `--from 10/1 to 10/31`.
    Has no effect unless the import plugin has implemented date range filtering.
  )
  c.arg_name 'DATE_OR_RANGE'
  c.flag %i[f from]

  c.desc 'Allow entries that overlap existing times'
  c.switch [:overlap], negatable: true

  c.action do |_global_options, options, args|

    if options[:section]
      options[:section] = wwid.guess_section(options[:section]) || options[:section].cap_first
    end

    if options[:from]
      date_string = options[:from]
      if date_string =~ / (to|through|thru|(un)?til|-+) /
        dates = date_string.split(/ (to|through|thru|(un)?til|-+) /)
        start = wwid.chronify(dates[0], guess: :begin)
        finish = wwid.chronify(dates[2], guess: :end)
      else
        start = wwid.chronify(date_string, guess: :begin)
        finish = false
      end
      raise Doing::Errors::InvalidTimeExpression, 'Unrecognized date string' unless start
      dates = [start, finish]
    end

    if options[:type] =~ Doing::Plugins.plugin_regex(type: :import)
      options[:no_overlap] = !options[:overlap]
      options[:date_filter] = dates
      wwid.import(args, options)
      wwid.write(wwid.doing_file)
    else
      raise Doing::Errors::InvalidPluginType, "Invalid import type: #{options[:type]}"
    end
  end
end

pre do |global, _command, _options, _args|
  # global[:pager] ||= wwid.config['paginate']

  Doing::Pager.paginate = global[:pager]

  $stdout.puts "doing v#{Doing::VERSION}" if global[:version]
  unless STDOUT.isatty
    Doing::Color::coloring = global[:pager] ? global[:color] : false
  else
    Doing::Color::coloring = global[:color]
  end

  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

on_error do |exception|
  if exception.kind_of?(SystemExit)
    false
  else
    Doing.logger.output_results
    true
  end
end

post do |global, _command, _options, _args|
  # Use skips_post before a command to skip this
  # block on that command only
  Doing.logger.output_results
end

around do |global, command, options, arguments, code|
  Doing.logger.debug('Pager:', "Global: #{global[:pager]}, Config: #{wwid.config['paginate']}, Pager: #{Doing::Pager.paginate}")
  Doing.logger.adjust_verbosity(global)

  if global[:stdout]
    Doing.logger.logdev = $stdout
  end

  wwid.default_option = global[:default]

  if global[:config_file] && global[:config_file] != wwid.config_file
    Doing.logger.warn(format('%sWARNING:%s %sThe use of --config_file is deprecated, please set the environment variable DOING_CONFIG instead.', colors.flamingo, colors.default, colors.boldred))
    Doing.logger.warn(format('%sTo set it just for the current command, use: %sDOING_CONFIG=/path/to/doingrc doing [command]%s',  colors.red, colors.boldwhite, colors.default))
    wwid.config_file = global[:config_file]
    wwid.config = nil
    wwid.configure({ ignore_local: true })
    # Doing.logger.info("Override config file #{wwid.config_file}")
  # else
  #   wwid.configure
  end

  if global[:doing_file]
    wwid.init_doing_file(global[:doing_file])
  else
    wwid.init_doing_file
  end

  wwid.auto_tag = !global[:noauto]

  wwid.config[:include_notes] = false unless global[:notes]

  code.call
end

exit run(ARGV)
